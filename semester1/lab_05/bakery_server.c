/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <pthread.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/time.h>

#include "bakery.h"

struct ThreadArgument
{
	int threadNumber;
	int threadResult;
	int threadId;
};

time_t currentTime;
struct tm *timeInformation;

int isChoosing[30] = { 0 };
int orderNumber[30] = { 0 };
int startingSymbol = 'a';
int orderCount = 0;
int indexThreadCreate = 0;
int indexThreadJoin = 0;

pthread_t workerThreads[30];

struct ThreadArgument threadsResults[30] = { 0 };

void *get_order(void *arg)
{
    struct ThreadArgument *threadArg = arg;
    int i = orderCount;
    orderCount++;
    threadArg->threadId = i;
    isChoosing[i] = 1;
    int max = 0;
    for (int j = 0; j < 30; j++)
        if (orderNumber[j] > max)
            max = orderNumber[j];
    orderNumber[i] = max + 1;
    threadArg->threadNumber = orderNumber[i];
    isChoosing[i] = 0;
    return 0;
}

void *process_bakery_order(void *arg)
{
    setbuf(stdout, NULL);
    time(&currentTime);
    timeInformation = localtime(&currentTime);
    
    struct timeval tv;
    struct tm *ptm;
    char time_string[40];
    long milliseconds;
    long microseconds;
    
    gettimeofday(&tv, NULL);
    ptm = localtime(&tv.tv_sec);
    strftime(time_string, sizeof(time_string), "%H:%M:%S", ptm);
    milliseconds = tv.tv_usec / 1000;
    microseconds = tv.tv_usec % 1000;
    struct ThreadArgument *threadArg = arg;
    printf("\nThread id = '%ld' started, client's order number = %d, time = %s:%03ld:%03ld\n", syscall(SYS_gettid), orderNumber[threadArg->threadId], time_string, milliseconds, microseconds);
    int i = threadArg->threadId;
    for (int j = 0; j < 30; j++)
    {
        while (isChoosing[j]);
        while ((orderNumber[j] > 0) && (orderNumber[j] < orderNumber[i] || (orderNumber[j] == orderNumber[i] && j < i)));
    }
    threadArg->threadResult = startingSymbol;
    startingSymbol++;
    sleep(5);
    gettimeofday(&tv, NULL);
    ptm = localtime(&tv.tv_sec);
    strftime(time_string, sizeof(time_string), "%H:%M:%S", ptm);
    milliseconds = tv.tv_usec / 1000;
    microseconds = tv.tv_usec % 1000;
    printf("\nThread id = '%ld' stopped, client's order number = %d, time = %s:%03ld:%03ld\n", syscall(SYS_gettid), orderNumber[i], time_string, milliseconds, microseconds);
    orderNumber[i] = 0;
    return 0;
}

struct BakeryOrder *
getorder_1_svc(struct BakeryOrder *argp, struct svc_req *rqstp)
{
	setbuf(stdout, NULL);
	static struct BakeryOrder bakeryResult;

	struct ThreadArgument threadResult;
	get_order(&threadResult);
	bakeryResult.pid = threadResult.threadId;
	bakeryResult.order_num = threadResult.threadNumber;

	return &bakeryResult;
}

struct BakeryOrder *
waitinqueue_1_svc(struct BakeryOrder *argp, struct svc_req *rqstp)
{
	setbuf(stdout, NULL);
	static struct BakeryOrder bakeryResult;

	pthread_t thread;
	threadsResults[indexThreadCreate].threadId = argp->pid;
	pthread_create(&thread, NULL, process_bakery_order, &threadsResults[indexThreadCreate]);
	workerThreads[indexThreadCreate] = thread;
	indexThreadCreate++;

	return &bakeryResult;
}

struct BakeryOrder *
processbakeryresult_1_svc(struct BakeryOrder *argp, struct svc_req *rqstp)
{
	setbuf(stdout, NULL);
	static struct BakeryOrder bakeryResult;

	pthread_join(workerThreads[indexThreadJoin], NULL);
	bakeryResult.pid = argp->pid;
	bakeryResult.order_result = threadsResults[indexThreadJoin].threadResult;
	indexThreadJoin++;

	return &bakeryResult;
}
